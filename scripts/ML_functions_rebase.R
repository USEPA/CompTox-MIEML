#functions for predicting MIEs with LINCS and refchemDB datasets
#rebased 6/9/2020
#rebased 9/21/2020


# clean_MIE_names - simple function for cleaning concatenated MIE names for plotting purposes
#
# Parameters:
#  x (vector)
# 
# Return Value:
#  (character vector) = vector of shortened MIE names for MIEs generated from multiple collapsed MIES

clean_MIE_names <- function(x){
  x = as.character(x)
  for (i in 1:length(x)){
    temp <- strsplit(x = as.character(x[i]), split = "[.]")
    if (lengths(temp) > 1){
      x[i] <- paste0(temp[[1]][1], "..")
    }
  }
  return(x)
}


# import_GSEA_signatures - import gene expression signatures and format for use in GSEA
#
# Parameters:
#  file_path (string)
# 
# Return Value:
#  (list) = list of signatures formatted for input to GSEA

import_GSEA_signatures <- function(file_path = "/share/projects/HTTr/HTTr_pipeline_dev/HumanWT_v1/Analysis/Bundy/input/c2.cp.v7.1.symbols.txt"){
  # Read in the data
  x <- scan(file_path, what="", sep="\n")
  # Separate elements by one or more whitepace
  y <- strsplit(x, "[[:space:]]+")
  # Extract the first vector element and set it as the list element name
  names(y) <- sapply(y, `[[`, 1)
  # Remove the first and second vector element from each list element
  y <- lapply(y, `[`, -c(1,2))
  return(y)
}



# tabulate_signature_sizes - calculate the size of signature objects generated by import_signatures()
#
# Parameters:
#  x (list) = list of signatures imported by import_signatures()
# 
# Return Value:
#  (dataframe) = dataframe of number of genes in each signature

table_GSEA_signatures <- function(x){
  output <- data.frame()
  for (i in 1:length(x)){
    name = names(x[i])
    length_sig <- length(x[[i]])
    entry <- data.frame("name" = name,"size" = length_sig)
    output <- rbind(output, entry)
  }
  return(output)
}



# calculate_jaccard - calculate the jaccard index for two sets vectors of elements
#
# Parameters:
#  x (vector)
#  y (vextor)
# 
# Return Value:
#  (numeric)

calculate_jaccard <- function(x,y){
  jaccard <- length(intersect(x, y))/length(union(x, y))
  return(jaccard)
}



# filter_refchem - import and filter refchem chemical-target associations 
# from refchemDB (specifically suplementary table 12)
#
# Parameters:
#  refchem_file_raw (character) = full system path to refchem csv file
#  support_level (integer) = level of support to 
#
# Return Value:
#  (data.frame)
#  returns a data frame with an additional column called target_mode generated by concatenating the 
#  target and mode fields

filter_refchem <- function(refchem_file_raw, 
                           support_level){
  require(data.table)
  refchem_manifest <- data.table(read.csv(header = TRUE, 
                                          file = refchem_file_raw))
  
  #remove entries where mode is unspecified and where support is lower than the specified cutoff
  refchem_manifest <-refchem_manifest[refchem_manifest$mode != "unspecified" & refchem_manifest$support >= support_level]
  output = data.frame()
  
  #get a list of all chemicals in refchemdb and iterate through these chemicals
  chemicals = unique(refchem_manifest$dsstox_substance_id)
  for (i in chemicals){
    #select rows associated with each chemical
    per_chemical_targets = refchem_manifest[dsstox_substance_id == i]
    #select targets associate with each chemical and iterate though targets
    target_list = unique(per_chemical_targets$target)
    for (j in target_list){
      #filter the rows down to only those associated with the target
      chem_by_target = per_chemical_targets[per_chemical_targets$target == j]
      #If there are multiple modes of support, then unspecified cannot be the only mode - remove it.
      #3/5/2020 this is redundant as we have already removed unspecified entries 
      if (length(chem_by_target$dsstox_substance_id) > 1){
        chem_by_target = chem_by_target[chem_by_target$mode != "unspecified"]
      }
      #select the target_mode with the greatest support and add this row to the output
      target_max <- head(chem_by_target[order(chem_by_target$support, decreasing = TRUE),],1)
      output = rbind(output, target_max)
    }
  }
  output$target_mode <- paste0(output$target, "_", output$mode)
  return(output)
}

# table_targets - tabulate the number of chemicals per target_mode
#
# Parameters:
#  chemical_manifest (data.frame) = filtered RefchemDB manifest with a target_mode column
# Return Value:
#  (data.frame) = data frame tabulating how many chemicals are available for each target_mode in RefChemDB
table_targets <- function(chemical_manifest){
  require(data.table)
  chemical_manifest <- data.table(chemical_manifest)
  setkey(chemical_manifest,target_mode)
  chemical_table <- chemical_manifest[,.(members = length(dsstox_substance_id)), by=target_mode]
  chemical_table <-chemical_table[order(members, decreasing = TRUE),]
  return(chemical_table)
}



# collapse_refchem_targets - imports, filters, and tables refchemDB target_modes, and then collapses them based on maximum
# dissimilarity as measured by jaccard index
#
# Parameters:
#  refchem_file_raw (character) = full system path to refchem csv file
#  support_levels (vector) = vector of support levels used in iterative binning of refchemDB target_modes
#  min_chemicals (integer) = minimum number of chemicals required in both members of a pair of target_modes to return a jaccard index value
#  h (numeric) = numeric between 0.0 and 0.1.  This is handed to cutree to determining the extent to which similar target_modes are binned
#  method (character) = a valid option for "method" for the hclust() function
#  write_out (boolean) = should the resulting object be written to an .Rdata file?
#  outdir (character) = a full path to outfile location if write_out == TRUE
#
# Return Value:
#  (list) = returns with the following elements
#  refchem_cleaned_collapsed (data.frame) = altered refchemdb manifest with collapsed target_modes
#  jaccard_matrix (data.frame)
#  groups (data.frame)

collapse_targets_static <- function(refchem_file_raw = "/share/projects/HTTr/HTTr_pipeline_dev/HumanWT_v1/Analysis/Bundy/refchem_explore/input/refchem.csv",
                                    support_levels = c(2,3,4,5),
                                    min_chemicals = 10,
                                    h = 0.2,
                                    method= "complete",
                                    write_out = FALSE,
                                    outdir = NULL)
{
  require(rlist)
  require(data.table)
  message("This will probably take some time...")
  message("importing refchem")
  refchem_cleaned <- filter_refchem(refchem_file_raw =  refchem_file_raw,
                                    support_level = min(support_levels))
  message("tabulating targets")
  target_table <- table_targets(refchem_cleaned)
  message("calculating jaccard indices")
  target_table <- target_table[target_table$members >= min_chemicals]
  refchem_cleaned = data.table(refchem_cleaned)
  #initialize matrix to catch iterations of similarity score
  matrix= data.frame()
  #iterate through each target_mode
  for (i in target_table$target_mode){
    #select only the rows associated with this target
    target_refchem = refchem_cleaned[refchem_cleaned$target_mode == i,]
    temp = c()
    #iterate through each target_mode again 
    for (j in target_table$target_mode){
      #select only the rows associated with this target
      query_refchem = refchem_cleaned[refchem_cleaned$target_mode == j,]
      support_temp = c()
      #iterate through each support level
      for (k in support_levels){
        #filter out records with a support level beneath the cutoff
        temp_target_refchem = target_refchem[target_refchem$support >= k,]
        temp_query_refchem = query_refchem[query_refchem$support >= k,]
        #after filtering, are there at least 10 chemicals in the target and query? If so, calculate the jaccard index and add to the list
        if (length(temp_target_refchem$dsstox_substance_id) >= min_chemicals & length(temp_query_refchem$dsstox_substance_id) >= min_chemicals){
          jaccard <- calculate_jaccard(x = temp_target_refchem$dsstox_substance_id, y = temp_query_refchem$dsstox_substance_id)
          support_temp <- c(support_temp, jaccard)
        }
      }
      #from the list of jaccard indexes just calculated, take the minimum jaccard index as the representative metric of similarity between those target_modes
      temp = c(temp, min(support_temp))
    }
    #transpose this column into a row
    temp = data.frame(t(temp))
    #assign names to these columns - is this really necessary?
    names(temp) <- target_table$target_mode
    #add the row of indexies to the growing matrix
    matrix = rbind(matrix, temp)
  }
  row.names(matrix) <- target_table$target_mode
  
  #convert similarities into dissimilarities
  neg_matrix = 1-matrix
  #calculate distance between each target_mode
  m_dist <- as.dist(m = data.frame(neg_matrix))
  #cluster the target_modes based on distance
  mhclust <- hclust(m_dist, method = method)
  
  #export grouping of target_mode labels using cutree
  groups <- data.frame("group" = cutree(mhclust, h = h))
  groups$name <- rownames(groups)
  
  message("editing chemical manifest")
  #tabulate the number of chemicals in each group
  table = data.frame(table(groups$group))

  #at this point we have a dataframe of groupings telling us which MIEs need to be collapsed 
  #iterate through this dataframe by group and generate a new chemical manifest
  for (i in 1:nrow(table)){
    #select the group name
    group = table[i,]$Var1
    #get a list of targets in this group
    targets <- groups[groups$group == group,]
    #order the targets alphanumerically - is this necessary?
    #WARNING - THIS STEP RETURNS DIFFERENT RESULTS ACROSS ENVIRONMENTS FOR CERTAIN MIES - UNSURE WHY
    #disabled on 7/14/2021 as this actually causes issues across platforms
    #targets <- targets[order(targets$name),]
    
    #go ahead and name each group after its first MIE member - and if there's more than one member, append "_group" to the end
    group_name = targets$name[1]
    if (nrow(targets) > 1){
      group_name <- paste0(group_name, "_group")
    }
    
    #iterate through target names for targets in this group and reassign them to the name of their group
    for (j in targets$name){
      refchem_cleaned[refchem_cleaned$target_mode ==j,]$target_mode <- group_name
      groups[groups$name == j,]$group <- group_name
    }
  }
  #write out this modified chemical manifest, as well as other useful objects, in a list
  preprocessed_collapsed_targets <- list("collapsed_targets" = refchem_cleaned, "jaccard_matrix" = matrix, "groups" = groups)
  #if desired, save object to disk
  if (write_out == TRUE){
    saveRDS(preprocessed_collapsed_targets, file = paste0(outdir, "/collapsed_targets", ".rds"))
  }
  return(preprocessed_collapsed_targets)
}  
  
  
  

#3/9/2020 need to rework this function - it is poorly written and reads in a lot of redundant info

# import_LINCS_metadata - import LINCS metadata from .csv files downloaded from GEO
#
# Parameters:
#  LINCS_directory (character) = full path to directory where LINCS files reside
#  chemical_manifest (data.frame) = filtered RefchemDB manifest with a target_mode column
#  cell_id (character) = cell type you want to model on - to see a list of available cell types in the LINCS dataset, use unique(cmap_metadata$cell_id)
#  pert_itime (character) = exposure you want to model on - to see a list of available times in the LINCS dataset, use unique(cmap_metadata$pert_itime)
#  filter_by_tas (boolean) = should data be filtered by TAS score
#  tas_filter (numeric) = between 0 and 1.  What quantile of all DMSO wells within this cell type should the TAS score for a signature exceede to remain
#
# Return Value:
#  (data.frame) = data frame of LINCS metadata
import_LINCS_metadata <- function(LINCS_directory, 
                                  chemical_manifest,
                                  DTXSID_index_file,
                                  cell_id, 
                                  pert_itime = "no_filter",
                                  filter_by_tas = FALSE,
                                  tas_filter = NULL){
  require(data.table)
  pert_annotations <-read.csv(DTXSID_index_file, header =TRUE)
  
  phase1_LINCS_sig_metrics <- data.table(read.csv(header = TRUE, file = paste0(LINCS_directory,"phase_1/GSE92742_Broad_LINCS_sig_metrics.txt"), sep = "\t"))
  phase1_LINCS_sig_info <- data.table(read.csv(header = TRUE, file = paste0(LINCS_directory,"phase_1/GSE92742_Broad_LINCS_sig_info.txt"), sep = "\t"))
  phase1_LINCS_sig_merged <- data.frame(merge(phase1_LINCS_sig_metrics, phase1_LINCS_sig_info, no.dups = FALSE))
  
  phase1_LINCS_pert_info <- data.table(read.csv(header = TRUE, file = paste0(LINCS_directory,"phase_1/GSE92742_Broad_LINCS_pert_info.txt"), sep = "\t"))
  phase1_LINCS_pert_info <- merge(phase1_LINCS_pert_info, pert_annotations, by = "pert_id")
  
  phase1_LINCS_metadata <- merge(phase1_LINCS_sig_merged, phase1_LINCS_pert_info, by = "pert_id")
  phase1_LINCS_metadata <- phase1_LINCS_metadata[phase1_LINCS_metadata$DTXSID %in% chemical_manifest$dsstox_substance_id,]
  phase1_LINCS_metadata$phase <- "phase1"
  
  phase2_LINCS_sig_metrics <- data.table(read.csv(header = TRUE, file = paste0(LINCS_directory,"phase_2/GSE70138_Broad_LINCS_sig_metrics.txt"), sep = "\t"))
  phase2_LINCS_sig_info <- data.table(read.csv(header = TRUE, file = paste0(LINCS_directory,"phase_2/GSE70138_Broad_LINCS_sig_info.txt"), sep = "\t"))
  phase2_LINCS_sig_merged <- data.frame(merge(phase2_LINCS_sig_metrics, phase2_LINCS_sig_info, no.dups = FALSE))
  
  phase2_LINCS_pert_info <- data.table(read.csv(header = TRUE, file = paste0(LINCS_directory,"phase_2/GSE70138_Broad_LINCS_pert_info.txt"), sep = "\t"))
  phase2_LINCS_pert_info <- merge(phase2_LINCS_pert_info, pert_annotations, by = "pert_id")
  
  phase2_LINCS_metadata <- merge(phase2_LINCS_sig_merged, phase2_LINCS_pert_info, by = "pert_id")
  phase2_LINCS_metadata <- phase2_LINCS_metadata[phase2_LINCS_metadata$DTXSID %in% chemical_manifest$dsstox_substance_id,]
  phase2_LINCS_metadata$phase <- "phase2"
  phase2_LINCS_metadata$is_exemplar <- 0
  
  #rebuild metadata object by combining relevant columns from both objects
  LINCS_metadata <- data.frame("pert_id" = c(as.matrix(phase1_LINCS_metadata$pert_id), as.matrix(phase2_LINCS_metadata$pert_id)),
                               "sig_id" = c(as.matrix(phase1_LINCS_metadata$sig_id), as.matrix(phase2_LINCS_metadata$sig_id)),
                               "DTXSID" = c(as.matrix(phase1_LINCS_metadata$DTXSID), as.matrix(phase2_LINCS_metadata$DTXSID)),
                               "cell_id" = c(as.matrix(phase1_LINCS_metadata$cell_id), as.matrix(phase2_LINCS_metadata$cell_id)),
                               "pert_itime" = c(as.matrix(phase1_LINCS_metadata$pert_itime), as.matrix(phase2_LINCS_metadata$pert_itime)),
                               "pert_iname" = c(as.matrix(phase1_LINCS_metadata$pert_iname.x), as.matrix(phase2_LINCS_metadata$pert_iname.x)),
                               "is_exemplar" = c(as.matrix(phase1_LINCS_metadata$is_exemplar), as.matrix(phase2_LINCS_metadata$is_exemplar)),
                               "phase" = c(as.matrix(phase1_LINCS_metadata$phase), as.matrix(phase2_LINCS_metadata$phase)),
                               "tas" = c(as.matrix(phase1_LINCS_metadata$tas), as.matrix(phase2_LINCS_metadata$tas)),
                               "pert_type" = c(as.matrix(phase1_LINCS_metadata$pert_type.x), as.matrix(phase2_LINCS_metadata$pert_type.x)))
  
  LINCS_metadata <- LINCS_metadata[LINCS_metadata$cell_id == cell_id & LINCS_metadata$pert_type == "trt_cp",]
  
  #if a pert exposure time is specified, filter on it
  if (pert_itime != "no_filter"){
    LINCS_metadata <- LINCS_metadata[LINCS_metadata$pert_itime == pert_itime,]
  }
  
  #if the filter switch is turned on, fitler out signatures with a tas lower than (tas_filter) proportion of DMSO wells with an equal or higher score
  if (filter_by_tas == TRUE){
    if (pert_itime != "no_filter"){
      DMSO_tas <- c(phase1_LINCS_sig_merged[phase1_LINCS_sig_merged$pert_id == "DMSO" & phase1_LINCS_sig_merged$cell_id == cell_id & phase1_LINCS_sig_merged$pert_itime == pert_itime,]$tas,
                    phase2_LINCS_sig_merged[phase2_LINCS_sig_merged$pert_id == "DMSO" & phase2_LINCS_sig_merged$cell_id == cell_id & phase2_LINCS_sig_merged$pert_itime == pert_itime,]$tas)
    }
    if (pert_itime == "no_filter"){
      DMSO_tas <- c(phase1_LINCS_sig_merged[phase1_LINCS_sig_merged$pert_id == "DMSO" & phase1_LINCS_sig_merged$cell_id == cell_id,]$tas,
                    phase2_LINCS_sig_merged[phase2_LINCS_sig_merged$pert_id == "DMSO" & phase2_LINCS_sig_merged$cell_id == cell_id,]$tas)
    }
    LINCS_metadata <- LINCS_metadata[LINCS_metadata$tas >= quantile(x = DMSO_tas, tas_filter),]
  }
  return(LINCS_metadata)
}



# trim_LINCS_metadata - subsets LINCS metadata dataframe selecting profiles from a specific cell type and pert time
#
# Parameters:
#  LINCS_metadata (data.frame) = data frame of LINCS metadata
#  profile_limit (numberic) = maximum number of profiles allowed for each chemical
#  seed (numeric) = seed for random selecting profiles for chems with more profiles than trim_profiles
#
# Return Value:
#  (data.frame) = data frame of filtered LINCS metadata
trim_LINCS_metadata <- function(LINCS_metadata,
                                profile_limit= 20,
                                seed = NULL){
  require(data.table)
  #LINCS_metadata = data.frame(LINCS_metadata)
  
  #tabulate the chemicals that are overrepresented with respect to their profile number
  overrepresented_chemicals <- data.table(LINCS_metadata)
  overrepresented_chemicals <- overrepresented_chemicals[,.(profile_number = length(sig_id)), by = DTXSID]
  overrepresented_chemicals <- overrepresented_chemicals[overrepresented_chemicals$profile_number > profile_limit]
  
  #remove these overrepresented chemicals from the dataset
  reduced_LINCS_metadata <- setdiff(LINCS_metadata$DTXSID, overrepresented_chemicals$DTXSID)
  reduced_LINCS_metadata <- LINCS_metadata[LINCS_metadata$DTXSID %in% reduced_LINCS_metadata,]
  
  #iterate through overrepresented chemicals, select n profiles, and add them back, n profiles at a time 
  for (i in overrepresented_chemicals$DTXSID){
    relevant_profiles_2 <- LINCS_metadata[LINCS_metadata$DTXSID == i,]
    set.seed(seed)
    select_2 <- sample(1:length(relevant_profiles_2$sig_id), profile_limit, replace = F)
    relevant_profiles_2 <- relevant_profiles_2[select_2,]
    reduced_LINCS_metadata <- rbind(reduced_LINCS_metadata, relevant_profiles_2)
  }
  return(data.table(reduced_LINCS_metadata))
}



# table_LINCS_profiles - generates a table of LINCS profiles available for training each target_mode model
#
# Parameters:
#  target_table (data.table) = table of tabulated target-modes generated by table_targets()
#  LINCS_metadata (data.table) = metadata object after filtering LINCS metadata
#  chemical_manifest (data.table) = cleaned and filtered refchemDB object
#  exemplar_refchems (data.frame)= optional dataframe of DTXSIDs corresponding exemplar refchems to exclude from tabulation
#  min_profiles (integer) = minimum number of LINCS profiles required for a target_mode to persist
#  min_chemicals (integer) = minimum number of the set of chemicals associated with LINCS profiles required for a target_mode to persist
#
# Return Value:
#  (data.frame) = data frame of target_modes and their number of associated chemicals and LINCS profiles

table_LINCS_profiles <- function(target_table, 
                                 LINCS_metadata, 
                                 chemical_manifest,
                                 exemplar_refchems = NULL,
                                 min_profiles = 0, 
                                 min_chemicals = 0){
  require(data.table)
  target_list <- target_table[members >= min_chemicals]$target_mode
  output = data.table()
  for (i in target_list){
    #select chemicals only associated with this target_mode
    temp_refchem_chems = chemical_manifest[chemical_manifest$target_mode == i,]
    #remove chemicals that show up in the exemplar_refchems object
    if (!is.null(exemplar_refchems)){
      temp_refchem_chems = temp_refchem_chems[temp_refchem_chems$dsstox_substance_id %in% setdiff(temp_refchem_chems$dsstox_substance_id, exemplar_refchems$dsstox_substance_id)]
    }
    
    temp_relevant_assays = LINCS_metadata[LINCS_metadata$DTXSID %in% temp_refchem_chems$dsstox_substance_id,]
    entry = data.frame("target_mode" = i, 
                       "LINCS_profiles" = length(temp_relevant_assays$pert_id),
                       "chemicals" = length(unique(temp_relevant_assays$DTXSID)))
    output = rbind(output, entry)
  }
  names(output) <- c("target_mode","LINCS_profiles", "chemicals")
  output <-output[order(LINCS_profiles, decreasing = TRUE),]
  output <-output[LINCS_profiles >= min_profiles]
  output <-output[chemicals >= min_chemicals]
  return(output)
}


# collapse_targets (deprecated, use collapse_targets_static instead) - collapses redundant target_modes for a refchemdb object that has already been 
# filtered by a custom support level
#
# Parameters:
#  refchem_cleaned (data.table) = cleaned and filtered refchemDB object
#  profile_table (data.frame) = table from table_LINCS_profiles() to iterate through for target_mode selection
#  h (numeric) = numeric between 0.0 and 0.1.  This is handed to cutree to determining the extent to which similar target_modes are binned
#  method (character) = a valid option for "method" for the hclust() function
#
# Return Value:
#  (list) = returns with the following elements
#  refchem_cleaned_collapsed (data.frame) = altered refchemdb manifest with collapsed target_modes
#  jaccard_matrix (data.frame)
#  groups (data.frame)

collapse_targets <- function(refchem_cleaned,
                             profile_table,
                             h,
                             method){
  refchem_cleaned_collapsed <- refchem_cleaned
  
  chemlist <- list()
  for (i in profile_table$target_mode){
    temp <- refchem_cleaned[refchem_cleaned$target_mode == i,]$name
    chemlist[[i]] <- temp
  }
  
  matrix = data.frame()
  for (i in names(chemlist)){
    target_chems = data.frame(chemlist[i])
    temp = c()
    for (j in names(chemlist)){
      query_chems = data.frame(chemlist[j])
      intersect <- length(intersect(target_chems[,1], query_chems[,1]))
      union <- length(union(target_chems[,1], query_chems[,1]))
      jaccard <- intersect/union
      temp <- c(temp, jaccard)
    }
    temp = data.frame(t(temp))
    names(temp) <- names(chemlist)
    matrix = rbind(matrix, temp)
  }
  row.names(matrix) <- names(chemlist)
  #matrix <- as.matrix(matrix)
  
  #heatmap(matrix, scale = "none", Rowv = NULL, cexRow = 0.7, cexCol = 0.7)
  
  neg_matrix = 1-matrix
  m_dist <- as.dist(m = data.frame(neg_matrix))
  mhclust <- hclust(m_dist, method = method)
  
  groups <- data.frame("group" = cutree(mhclust, h = h))
  groups$name <- rownames(groups)
  
  table = data.frame(table(groups$group))
  #table = table[table$Freq > 1,]
  for (i in 1:length(table$Var1)){
    group = table[i,]$Var1
    #  group_name <- paste0("group_", group)
    targets <- groups[groups$group == group,]
    targets <- targets[order(targets$name),]
    group_name <- ""
    for (k in targets$name){
      group_name <- paste0(group_name, ".", k)
    }
    for (j in targets$name){
      refchem_cleaned_collapsed[refchem_cleaned_collapsed$target_mode ==j,]$target_mode <- group_name
    }
  }
  
  output <- list("refchem_cleaned_collapsed" = refchem_cleaned_collapsed, 
                 "jaccard_matrix" = matrix,
                 "groups" = groups)
  return(output)  
}



# fetch_exemplar_refchems - selects the chemicals present in LINCS with the highest level of support for each target_mode
#
# Parameters:
#  chemical_manifest (data.frame) = refchemDB object with target_modes, chemicals, and support levels
#  profile_table (data.frame) = table containing a target_mode field to iterate through
#  cmap_metadata (data.table) = metadata object after filtering cmap metadata
#
# Return Value:
#  (data.frame) = returns a dataframe of target_modes, their top chemicals, and their support level
fetch_exemplar_refchems <- function(chemical_manifest,
                                    LINCS_metadata,
                                    profile_table){
  #step through the profile table to select a top exemplar reference chemical for each target_mode
  exemplar_usage_table <- data.frame()
  for (i in profile_table$target_mode){
    #select only refchemdb annotations for target_mode i
    relevant_manifest <- chemical_manifest[chemical_manifest$target_mode == i,]
    
    #select only the annotations that are also present in LINCS
    relevant_manifest <- relevant_manifest[relevant_manifest$dsstox_substance_id %in% LINCS_metadata$DTXSID,]
    
    #order the annotations by support
    relevant_manifest <- relevant_manifest[order(relevant_manifest$support, decreasing = TRUE),]
    
    #deduplicate the annotations by substance_id - since the table was generated using the "target_mode" field from a collapsed refchemdb database, there are likely to be multiple entries with the same chemical-target_mode linkage, as records are still by target 
    relevant_manifest_dedup <- relevant_manifest[!duplicated(relevant_manifest$dsstox_substance_id), ]
    
    
    if (length(relevant_manifest$dsstox_substance_id) > 0){
      #select top 5 exemplar reference chemicals
      entry = relevant_manifest_dedup[order(relevant_manifest_dedup$support, decreasing = TRUE),][1:min(nrow(relevant_manifest_dedup),5),]
      exemplar_usage_table <- rbind(exemplar_usage_table, entry)
    }
  }
  #table the number of targets each chemical is associated with and sort the table
  tabled_exemplar_freq <- data.frame(table(exemplar_usage_table$dsstox_substance_id))
  tabled_exemplar_freq <- tabled_exemplar_freq[order(tabled_exemplar_freq$Freq, decreasing = TRUE),]
  
  output <- data.frame()
  #step through each chemical and select the targets with which it is associated
  for (i in 1:length(tabled_exemplar_freq$Var1)){
    chem = tabled_exemplar_freq$Var1[i]
    relevant_targets <- exemplar_usage_table[exemplar_usage_table$dsstox_substance_id == chem,]
    
    #remove any target_modes already represented in output with a different reference chemical
    relevant_targets <- relevant_targets[relevant_targets$target_mode %in% setdiff(relevant_targets$target_mode,output$target_mode),]
    
    #add these entries to growing list
    output <- rbind(output, relevant_targets)
  }
  
  
  return(output)
}


# fetch_exemplar_refchems_2 - selects the chemicals present in LINCS with the highest level of support for each target_mode
#
# Parameters:
#  chemical_manifest (data.frame) = refchemDB object with target_modes, chemicals, and support levels
#  profile_table (data.frame) = table containing a target_mode field to iterate through
#  cmap_metadata (data.table) = metadata object after filtering cmap metadata
#
# Return Value:
#  (data.frame) = returns a dataframe of target_modes, their top chemicals, and their support level
fetch_exemplar_refchems_2 <- function(chemical_manifest,
                                      LINCS_metadata,
                                      profile_table,
                                      min_profiles,
                                      min_chemicals,
                                      target_table){
  
  
  #step through the profile table to select a top exemplar reference chemical for each target_mode
  exemplar_usage_table <- data.frame()
  for (i in profile_table$target_mode){
    #select only refchemdb annotations for target_mode i
    relevant_manifest <- chemical_manifest[chemical_manifest$target_mode == i,]
    
    #select only the annotations that are also present in LINCS
    relevant_manifest <- relevant_manifest[relevant_manifest$dsstox_substance_id %in% LINCS_metadata$DTXSID,]
    
    #order the annotations by support
    relevant_manifest <- relevant_manifest[order(relevant_manifest$support, decreasing = TRUE),]
    
    #deduplicate the annotations by substance_id - since the table was generated using the "target_mode" field from a collapsed refchemdb database, there are likely to be multiple entries with the same chemical-target_mode linkage, as records are still by target 
    relevant_manifest_dedup <- relevant_manifest[!duplicated(relevant_manifest$dsstox_substance_id), ]
    
    
    if (length(relevant_manifest$dsstox_substance_id) > 0){
      #select top 5 exemplar reference chemicals
      entry = relevant_manifest_dedup[order(relevant_manifest_dedup$support, decreasing = TRUE),][1:min(nrow(relevant_manifest_dedup),10),]
      exemplar_usage_table <- rbind(exemplar_usage_table, entry)
    }
  }
  #table the number of targets each chemical is associated with and sort the table
  tabled_exemplar_freq <- data.frame(table(exemplar_usage_table$dsstox_substance_id))
  tabled_exemplar_freq <- tabled_exemplar_freq[order(tabled_exemplar_freq$Freq, decreasing = TRUE),]
  
  output <- data.frame()
  
  chemical_manifest_temp <- chemical_manifest
  #step through each chemical and select the targets with which it is associated
  for (i in 1:length(tabled_exemplar_freq$Var1)){
    chem = tabled_exemplar_freq$Var1[i]
    
    #generate a temp profile table that accounts for the loss of the chemical
    profile_table_temp <- table_LINCS_profiles(target_table = target_table,
                                               LINCS_metadata = LINCS_metadata,
                                               chemical_manifest = chemical_manifest_temp[chemical_manifest_temp$dsstox_substance_id != chem,],
                                               min_profiles = min_profiles,
                                               min_chemicals =  min_chemicals)
    
    #test if the exclusion of this chemical will drop a target below min_profiles
    if (length(setdiff(profile_table$target_mode, profile_table_temp$target_mode)) == 0){
      
      #if this is not the case, go ahead and remove its entries from the chemical_manifest_temp object to account for its loss
      chemical_manifest_temp = chemical_manifest_temp[chemical_manifest_temp$dsstox_substance_id != chem,]  
      
      relevant_targets <- exemplar_usage_table[exemplar_usage_table$dsstox_substance_id == chem,]
      
      #remove any target_modes already represented in output with a different reference chemical
      relevant_targets <- relevant_targets[relevant_targets$target_mode %in% setdiff(relevant_targets$target_mode,output$target_mode),]
      
      #add these entries to growing list
      output <- rbind(output, relevant_targets)
    }
  }
  
  
  return(output)
}






# fetch_LINCS_profiles - import LINCS level 5 moderated z-scores and normalize if necessary
#
# ***9/21/2020 in the interest of generating normalization that is static, might we re-organize this function to first pull in all LINCS profiles
# of the correct celltype and pert itime (if specified) and normalize using the full set before parsing it down?  This would ensure that 
# the data remain constant even if filtering criteria are altered
#
# Parameters:
#  LINCS_raw_directory (character) = directory where LINCS raw data reside - needs to be organized into 
#  phase_1 and phase_2 subdirectories with the unpacked .gctx files in thei respective locations
#  LINCS_metadata (data.table) = metadata object after filtering cmap metadata
#  normalize (boolean) - should data be standardized 
#
# Return Value:
#  (data.frame?) = dataframe of standardized LINCS gene expression values

fetch_LINCS_profiles <- function(LINCS_raw_directory = "/share/projects/HTTr/HTTr_pipeline_dev/HumanWT_v1/Analysis/Bundy/cmap_explore/input/", 
                                 LINCS_metadata,
                                 normalize = TRUE){
  require(cmapR)
  require(data.table)
  require(caret)
  phase1_cmap_data <- parse.gctx(paste0(LINCS_raw_directory, "phase_1/GSE92742_Broad_LINCS_Level5_COMPZ.MODZ_n473647x12328.gctx"), cid=LINCS_metadata[LINCS_metadata$phase == "phase1",]$sig_id)
  phase2_cmap_data <- parse.gctx(paste0(LINCS_raw_directory, "phase_2/GSE70138_Broad_LINCS_Level5_COMPZ_n118050x12328_2017-03-06.gctx"), cid=LINCS_metadata[LINCS_metadata$phase == "phase2",]$sig_id)
  cmap_mat <- rbind(data.table(t(phase1_cmap_data@mat)),data.table(t(phase2_cmap_data@mat)))
  if (normalize == TRUE){
    preProcValues_standardized <- preProcess(cmap_mat, method = c("center", "scale"))
    cmap_mat <-  predict(preProcValues_standardized, cmap_mat)
  }
  cmap_mat$sig_id <- data.frame("sig_id" = c(as.matrix(phase1_cmap_data@cdesc$id),as.matrix(phase2_cmap_data@cdesc$id)))
  row.names(cmap_mat) <- cmap_mat$sig_id
  return(cmap_mat)
}



# format_signature_collection (deprecated) - format a list of signatures into the correct format for MYGSEA analysis
#
# 6/11/2020 - this shouldn't really be needed anymore now that signature collections are pulled directly from source
#
# Parameters:
#   collection (list) = imported sigdb object - prefereably subsetted 
# Return value:
# (list) = reformatted list of relevant signatures ready to be used by GSEA

# format_signature_collection <- function(collection){
#   output <- list()
#   for (i in 1:length(collection$signature)){
#     signature = collection[i,]$signature
#     gene_names <- unlist(strsplit(x = relevant_signatures[i,]$gene.list, "[|]"))
#     output <- list.append(output, gene_names)
#   }
#   names(output) <- collection[,1]
#   return(output)
# }



# format_signature_collection (deprecated) - format MSigDB file for pathway score calculation
#
# deprecated 3/6/2020 - use import_GSEA_signautures instead
#
# Parameters:
#   relevant_subset (character) = subset of signatures to be used in analysis i.e.  "H: hallmark gene sets"
#   MSigDB_file (character) = full path to MSigDB_file .Rdata file that Richard put together for this analysis

# Return value:
# (data.frame) = normalized pathway scores calculated from gene expression changes

# format_signature_collection <- function(relevant_subset = "H: hallmark gene sets", MSigDB_file = "/share/projects/HTTr/HTTr_pipeline_dev/HumanWT_v1/Analysis/Bundy/HTTR_repos/httrpathway/data/signatureDB.RData"){
#   
#   require(rlist)
#   
#   load(MSigDB_file)
#   collection <- subset(sigdb, subsource == relevant_subset)
#   
#   output <- list()
#   for (i in 1:length(collection$signature)){
#     signature = collection[i,]$signature
#     gene_names <- unlist(strsplit(x = collection[i,]$gene.list, "[|]"))
#     output <- list.append(output, gene_names)
#   }
#   names(output) <- collection[,1]
#   return(output)
# }



# calculate_pathway_scores - calculate pathway scores from LINCS expression profiles using GSEA
#
# Parameters:
#   LINCS_matrix (data.frame) = lincs gene expression matrix to be used for modeling
#   signature_list (list) = formatted list of signatures to be used by GSEA
#   gene_info (data.frame) = gene information to be merged with lincs_matrix to associate gene symbols
#   LINCS_metadata (data.frame) = metadata associated with the lincs_matrix
#   normalize (boolean) = should pathway scores be normalized
#
# Return value:
# (data.frame) = normalized pathway scores calculated from gene expression changes

calculate_pathway_scores <- function(LINCS_matrix, 
                                     signature_list, 
                                     gene_info, 
                                     LINCS_metadata,
                                     normalize = TRUE,
                                     cores = NULL){
  require(data.table)
  require(doParallel)
  require(foreach)
  require(caret)
  #transpose matrix
  message("- transposing matrix, this may take some time -\n")
  LINCS_matrix <- data.frame(t(LINCS_matrix))
  #remove the sig_id row
  LINCS_matrix <- data.frame(LINCS_matrix[!(row.names(LINCS_matrix) %in% c("sig_id")),])
  #name columns by sig_id
  names(LINCS_matrix) <- LINCS_metadata$sig_id
  #add a new column for gene ID so this matrix can be matched with gene info
  LINCS_matrix$pr_gene_id <- row.names(LINCS_matrix)
  #merge the matrix with the gene info object
  merged_profile <- merge(LINCS_matrix,gene_info, by = "pr_gene_id")
  #now that matrix probes are matched with gene symbols, remove all non-sample columns from data frame
  LINCS_matrix <- merged_profile[, -which(names(merged_profile) %in% c("pr_gene_id","pr_gene_symbol", "pr_gene_title", "pr_is_lm", "pr_is_bing"))]
  #change row names to gene symbols for GSEA analysis
  row.names(LINCS_matrix) <- merged_profile$pr_gene_symbol
  #for GSEA we use 10 cores, as this should be run one at a time
  if (is.null(cores)){
    tempcores = cores=detectCores() - 2
    registerDoParallel(cores=detectCores() - 2)
  }
  if (!is.null(cores)){
    tempcores = cores
    registerDoParallel(cores=tempcores)
  }
  #run parallelized GSEA analysis
  message("- calculating signature scores using ", tempcores, " cores -\n")
  LINCS_matrix <- foreach(i=1:length(LINCS_matrix[1,]), .combine = 'cbind') %dopar% {
    temp = LINCS_matrix[i]
    MYGSEA(X = temp, geneSets = signature_list, min.sz = 5)
  }
  #convert result to a dataframe
  LINCS_matrix <- data.frame(LINCS_matrix)
  #set cores back to function specified value
  registerDoParallel(cores=cores)
  
  nfactor = (range(LINCS_matrix)[2] - range(LINCS_matrix)[1])
  LINCS_matrix = data.table(t(LINCS_matrix/nfactor))
  
  if (normalize == TRUE){
    preProcValues_standardized <- preProcess(LINCS_matrix, method = c("center", "scale"))
    LINCS_matrix <-  predict(preProcValues_standardized, LINCS_matrix)
  }
  
  LINCS_matrix$sig_id = LINCS_metadata$sig_id
  row.names(LINCS_matrix) <- LINCS_metadata$sig_id
  return(data.table(LINCS_matrix))
}



# hms_span - convert a set of time stamps into a duration formatted in "hh:mm:ss"
#
# Parameters:
#  start (character) = start time from Sys.time()
#  end (character) = end time from Sys.time()
# Return Value:
#  (character) = character vector formatted in "hh:mm:ss"
hms_span <- function(start, end){
  dsec <- as.numeric(difftime(end, start, unit = "secs"))
  hours <- floor(dsec / 3600)
  minutes <- floor((dsec - 3600 * hours) / 60)
  seconds <- dsec - 3600*hours - 60*minutes
  paste0(
    sapply(c(hours, minutes, seconds), function(x) {
      formatC(x, width = 2, format = "d", flag = "0")
    }), collapse = ":")
}



# fetch_LINCS_for_target - format LINCS metadata and profiles for ML 
#
# Parameters:
# seed (numeric) = numeric seed to control RNG for reproducibility 
# generate_noise (either 1 or 0) = should the chemical-target relationships be true (0) or j
# target_name (character) = name of target to pull LINCS data for
# exemplar_refchems (dataframe) = data frame of appropriately formated exemplar refchems
# refchem_file (character) = full file path to raw refchem file
# chemical_manifest (dataframe) = data frame of formatted refchemdb
# LINCS_metadata (dataframe) = data frame of LINCS metadata
# LINCS_matrix (dataframe) = data frame of LINCS gene expression profiles
# null_pred_size (numeric) = number of profiles to be used for generating aux null distribution
#
# Return Value:
#  (list) = list containing relevant LINCS metadata and gene expression profiles for modeling

fetch_LINCS_for_target <- function(seed = 123,
                                   generate_noise = FALSE,
                                   target_name,
                                   exemplar_refchems,
                                   refchem_file_raw,
                                   chemical_manifest,
                                   LINCS_metadata,
                                   LINCS_matrix,
                                   null_pred_size){
  #########################
  require(data.table)
  require(dplyr)
  #disabled 10/2/2020
  #exemplar_refchems <- exemplar_refchems[exemplar_refchems$use_me == 1,]
  
  #select from refchem only the chemicals associated with target
  target_refchem_data <- chemical_manifest[chemical_manifest$target_mode == target_name,]
  
  #remove any chemicals from this dataframe that are also in our top_reference_chems object - they are to 
  #be excluded from all training
  exclude <- intersect(exemplar_refchems$dsstox_substance_id, unique(target_refchem_data$dsstox_substance_id))
  if(length(exclude) >0){
    target_refchem_data <- target_refchem_data[target_refchem_data$dsstox_substance_id %in% setdiff(target_refchem_data$dsstox_substance_id, exclude)]
  }
  
  #select from LINCS only the signatures associated with these chemicals
  target_LINCS_metadata <- LINCS_metadata[LINCS_metadata$DTXSID %in% target_refchem_data$dsstox_substance_id,]
  
  
  #if generate_noise is not 0, replace the target_LINCS_metadata object with similarly structured dummy metadata
  if(generate_noise == TRUE){
    
    #trim down LINCS profiles to only include chemicals annotated in the current refchemDB object - this is to eliminate bias of possibly selecting 
    #chemicals that have no biological effect.  For a chemical to be randomly selected for permuted model, it must be annotated as doing something at the relevant support level
    
    high_support_LINCS <- LINCS_metadata[LINCS_metadata$DTXSID %in% chemical_manifest$dsstox_substance_id,]
    
    #generate a table of the number of available profiles for every chemical in LINCS
    available_profiles <- high_support_LINCS[,. (profiles = length(sig_id)), by = DTXSID]
    
    #generate a table of the number of profiles associated with the chemicals for this target
    temp_table <- target_LINCS_metadata[,. (profiles = length(sig_id)), by = DTXSID]
    
    #initialize a noise_metadata object to catch synthetic metadata
    noise_metadata <- data.frame()
    
    #iterate through each row of this table, randomly select a chemical with as many profiles, and add it to the noise table
    for (i in 1:nrow(temp_table)){
      
      #first restrict available profiles only to chemicals that haven't already been added to the noise_metadata list
      available_profiles <- available_profiles[available_profiles$DTXSID %in% setdiff(available_profiles$DTXSID, noise_metadata$DTXSID),]
      
      #randomly pick a chemical's metadata for a chemical that has at least as many profiles as the true chemical
      temp_chem <- sample_n(tbl = available_profiles[available_profiles$profiles >= temp_table$profiles[i]], size = 1)
      
      #select the metadata for this chemical
      temp_metadata <- high_support_LINCS[high_support_LINCS$DTXSID == temp_chem$DTXSID,]
      
      #trim the metadata for this chemical down to size matched set of metadata
      set.seed(seed)
      temp_metadata <- sample_n(tbl = temp_metadata, size = temp_table$profiles[i], replace = FALSE)
      
      #add this metadata to output
      noise_metadata <- rbind(noise_metadata, temp_metadata)
    }
    
    target_LINCS_metadata <- noise_metadata
  }
  
  
  #select from LINCS the signatures associated with our top reference chemicals
  exemplar_refchems_LINCS_metadata <- LINCS_metadata[LINCS_metadata$DTXSID %in% exemplar_refchems$dsstox_substance_id,]
  
  #exclude these signatures from the metadata object - they are not to be used in predictions or holdout or training
  LINCS_metadata <- LINCS_metadata[LINCS_metadata$sig_id %in% setdiff(LINCS_metadata$sig_id, exemplar_refchems_LINCS_metadata$sig_id),]
  
  #sample up to 5 profiles for each of these reference chemicals
  exemplar_refchems_LINCS_metadata_sampled <- data.frame()
  
  for (i in unique(exemplar_refchems_LINCS_metadata$DTXSID)){
    relevant_profiles <- exemplar_refchems_LINCS_metadata[exemplar_refchems_LINCS_metadata$DTXSID == i,]
    
    #if there are more than 5 profiles for this chemical, randomly select 5 profiles
    if (length(relevant_profiles$sig_id) > 5){
      set.seed(seed)
      select <- sample(1:length(relevant_profiles$sig_id), 5, replace = F)
      relevant_profiles <- relevant_profiles[select,]
    }
    exemplar_refchems_LINCS_metadata_sampled <- rbind(exemplar_refchems_LINCS_metadata_sampled, relevant_profiles)
  }
  
  exemplar_refchems_LINCS_metadata_sampled$label <- "exemplar"
  exemplar_refchems_LINCS_metadata_sampled$use <- "pred"
  
  #generate list of targets to exlude from selection of null profiles - notice this is target and not target mode 
  targets_to_exclude_from_null <- unique(target_refchem_data$target)
  
  #import unchanged refchem file for purposes of exluding chemicals from null profile selection
  refchem_raw <- read.csv(file = refchem_file_raw, header = TRUE)
  
  #generate list of chemicals associated with target to exclude from null
  chemicals_to_exclude_from_null <- unique(refchem_raw[refchem_raw$target %in% targets_to_exclude_from_null,]$dsstox_substance_id)
  
  #select LINCS data not associated with this target
  null_LINCS_metadata<- setdiff(LINCS_metadata$DTXSID,chemicals_to_exclude_from_null)
  null_LINCS_metadata <- LINCS_metadata[LINCS_metadata$DTXSID %in% null_LINCS_metadata,]
  
  #assign label to target and null sets
  target_LINCS_metadata$label <- "target"
  null_LINCS_metadata$label <- "null"
  
  #generate hold out target metadata data
  num_holdout <- length(target_LINCS_metadata$sig_id) * 0.2
  set.seed(seed)
  target_LINCS_metadata_holdout <- sample(1:length(target_LINCS_metadata$sig_id), num_holdout, replace = F)
  target_LINCS_metadata_holdout <- target_LINCS_metadata[target_LINCS_metadata_holdout,]
  
  set.seed(seed)
  null_LINCS_metadata_holdout <- sample(1:length(null_LINCS_metadata$sig_id), num_holdout, replace = F)
  null_LINCS_metadata_holdout <- null_LINCS_metadata[null_LINCS_metadata_holdout,]
  
  #generate set of profiles for building null prediction distribution
  
  #first generate a list of signatures not already selected null holdout - don't want to use the same LINCS signature multiple times
  available_null_sigs <- setdiff(null_LINCS_metadata$sig_id, null_LINCS_metadata_holdout$sig_id)
  available_null_LINCS_metadata <- null_LINCS_metadata[null_LINCS_metadata$sig_id %in% available_null_sigs,]
  
  set.seed(seed)
  null_LINCS_metadata_null_pred <- sample(1:length(available_null_LINCS_metadata$sig_id), null_pred_size, replace = F)
  null_LINCS_metadata_null_pred <- available_null_LINCS_metadata[null_LINCS_metadata_null_pred,]
  null_LINCS_metadata_null_pred$use <- "pred"
  
  
  #remove holdout and prediction signatures from target and null objects
  keep <- setdiff(target_LINCS_metadata$sig_id, target_LINCS_metadata_holdout$sig_id)
  target_LINCS_metadata <- target_LINCS_metadata[target_LINCS_metadata$sig_id %in% keep,]
  
  keep <- setdiff(null_LINCS_metadata$sig_id, c(as.matrix(null_LINCS_metadata_holdout$sig_id), as.matrix(null_LINCS_metadata_null_pred$sig_id)))
  null_LINCS_metadata <- null_LINCS_metadata[null_LINCS_metadata$sig_id %in% keep,]
  
  
  #trim null dataset (randomly) to be the same size as the target to ballance class labels
  set.seed(seed)
  rows_to_keep <-sample(1:length(null_LINCS_metadata$pert_id),
                        length(target_LINCS_metadata$pert_id), replace = F)
  null_LINCS_metadata <- null_LINCS_metadata[rows_to_keep,]
  
  #concatenate target and null datasets
  LINCS_metadata_train <- data.frame(rbind(target_LINCS_metadata, null_LINCS_metadata), "use" = "train")
  LINCS_metadata_holdout <- data.frame(rbind(target_LINCS_metadata_holdout, null_LINCS_metadata_holdout), "use" = "holdout")
  
  #concatenate training, holdout, exemplar, and null pred metadata
  LINCS_metadata <- data.frame(rbind(LINCS_metadata_train,
                                     LINCS_metadata_holdout,
                                     exemplar_refchems_LINCS_metadata_sampled,
                                     null_LINCS_metadata_null_pred))
  
  #subset LINCS profiles down to those that are included in metadata
  LINCS_matrix <- LINCS_matrix[LINCS_matrix$sig_id %in% LINCS_metadata$sig_id,]
  
  #reorder the cmap matrix so that profiles match up with the labels in metadata
  LINCS_matrix <- LINCS_matrix[match(LINCS_metadata$sig_id, LINCS_matrix$sig_id)]
  
  
  LINCS_matrix$use <- LINCS_metadata$use
  LINCS_matrix$label <- LINCS_metadata$label
  
  return(list("LINCS_matrix" = LINCS_matrix, "LINCS_metadata" = LINCS_metadata))
}



# format_LINCS_for_ML - simple function for selecting chunks of LINCS data for specific use
#
# Parameters:
# LINCS_matrix (dataframe) = data frame of LINCS gene expression profiles
# use_field (character) = filter for use_field column for subsetting LINCS matrix
# label_field (character) = filter for label_field column for subsetting LINCS matrix
# Return Value:
#  (dataframe) = dataframe containing only the relevant LINCS profiles for modeling

format_LINCS_for_ML <- function(LINCS_matrix,
                                use_field = NULL,
                                label_field = NULL){
  if (!is.null(use_field)){
    LINCS_matrix = LINCS_matrix[LINCS_matrix$use == use_field,]
  }
  if (!is.null(label_field)){
    LINCS_matrix = LINCS_matrix[LINCS_matrix$label == label_field,]
  }
  LINCS_matrix$use <- NULL
  LINCS_matrix$label <- NULL
  LINCS_matrix$sig_id <- NULL
  return(LINCS_matrix)
}



# model_target - generate a predictive model for a single target_mode using refchemDB labels and LINCS gene expression
#
# Parameters:
#  target (character) = name of the target_mode to for which a model should be trained
#  support_level (integer) = minimal support level used to filter refchemDB - this isn't explicitly used other than to record this parameter in output
#  pert_itime (character) = filtering criteria used to filter cmap_metadata - this isn't explicitly used other than to record this parameter in output
#  cell_id (character) = filtering criteria used to filter cmap_metadata - this isn't explicitly used other than to record this parameter in output
#  feature_opt (character) = either "all_genes" or "landmark_genes" or "pathway_score" - indicates what features will be used for modeling
#  model_names (vector) = vector of characters corresponding to model types recognized by caret 
#  LINCS_matrix (dataframe) = large LINCS dataframe containing gene expression values to be used for prediction
#  LINCS_metadata (data.table) = metadata object after filtering cmap metadata
#  chemical_manifest (data.table) = cleaned and filtered refchemDB object
#  return_model (boolean) = whether to export full model information along with result summary
#  seed (integer) = seed for controling RNG for reproducibility
#  verbose (boolean) = whether to print status messages to console
#  null_pred_size (integer) = number of null profiles for model to generate predictions for
#  gene_info (data.frame) = gene metadata linking probes to gene names
#  top_refchems (data.frame) = table of reference chemicals to exclude from training and to predict on
#  save_model (boolean) = should the full model be saved to disk
#  output_dir (character) = full output path to where model should be saved - only relevant if save_model is TRUE
#  generate_noise (boolean) = should chemical-MIE relationships be permuted?
#
# Return Value:
#  (list) = returns a list containing two elements: a "results" dataframe that tabulates results metrics for each model and a 
#  "model_objects" list which contains more detailed model information for each model trained
model_target <- function(target_name, 
                         allowParallel_training = FALSE,
                         support_level = 5,
                         generate_noise = FALSE,
                         pert_itime,
                         cell_id,
                         feature_opt,
                         model_names, 
                         LINCS_matrix, 
                         LINCS_metadata, 
                         chemical_manifest, 
                         return_model = FALSE, 
                         seed = 123, 
                         verbose = TRUE,
                         null_pred_size = 200,
                         gene_info,
                         exemplar_refchems,
                         refchem_file_raw,
                         save_model = FALSE,
                         output_dir = NULL){
  require(data.table)
  require(caret)
  require(rlist)
  require(doParallel)
  .datatable.aware=TRUE
  
  if (allowParallel_training == TRUE){
    registerDoParallel(cores=floor(sqrt(detectCores())))
  }
  
  op <- options(digits.secs = 2)
  
  
  #internal timer for run time for each target
  loop_start_time <- Sys.time()  
  
  #initialize dataframe to catch results
  results_summary = data.frame()
  model_objects = list()
  
  #pull relevant LINCS metadata and profiles for this target
  LINCS_data <- fetch_LINCS_for_target(seed = seed,
                                       target_name = target_name,
                                       generate_noise = generate_noise,
                                       exemplar_refchems = exemplar_refchems,
                                       LINCS_matrix = LINCS_matrix,
                                       LINCS_metadata = LINCS_metadata,
                                       chemical_manifest = chemical_manifest,
                                       null_pred_size = null_pred_size,
                                       refchem_file_raw = refchem_file_raw)
  
  #intialize train.control for 5 fold cross validation
  train.control <- trainControl(classProbs =  TRUE,method = "cv", number = 5, verboseIter = verbose, returnData = TRUE, allowParallel = allowParallel_training)
  
  target_results=data.frame()
  for (model_name in model_names){
    
    loop_start_time<- Sys.time()
    
    #reduce the number of null profiles to predict on for nb - as this takes a very long time
    # if (model_name == "nb"){
    #   null_pred_size = null_pred_size/5
    # }
    
    message(paste0("- Modeling ", target_name, " with ", model_name, " -\n"))
    
    standardized_model <- train(x = format_LINCS_for_ML(LINCS_matrix = LINCS_data$LINCS_matrix,
                                                        use_field = "train"), 
                                y = as.factor(LINCS_data$LINCS_metadata[LINCS_data$LINCS_metadata$use == "train",]$label), 
                                method = model_name ,trControl = train.control)
    
    message("- finished training, predicting holdout values -\n")
    holdout_predictions <- predict.train(standardized_model, newdata = format_LINCS_for_ML(LINCS_matrix = LINCS_data$LINCS_matrix,
                                                                                           use_field = "holdout"))
    message("- generating confusion matrix -\n")
    holdout_results <- confusionMatrix(data = holdout_predictions, 
                                       reference = as.factor(LINCS_data$LINCS_metadata[LINCS_data$LINCS_metadata$use == "holdout",]$label), mode = "everything")
    message("- finished confusion matrix, caluclating probabilities -\n")
    
    #calculate probability predictions for the null dataset as a background, and recalculate prediction for holdout with actual probability 
    null_predictions <- predict(standardized_model, 
                                newdata = format_LINCS_for_ML(LINCS_matrix = LINCS_data$LINCS_matrix,
                                                              use_field = "pred",
                                                              label_field = "null"), type = "prob")
    
    holdout_predictions_target <- predict(standardized_model, 
                                          newdata = format_LINCS_for_ML(LINCS_matrix = LINCS_data$LINCS_matrix,
                                                                        use_field = "holdout",
                                                                        label_field = "target"), type = "prob")
    
    holdout_predictions_null <- predict(standardized_model, 
                                        newdata = format_LINCS_for_ML(LINCS_matrix = LINCS_data$LINCS_matrix,
                                                                      use_field = "holdout",
                                                                      label_field = "null"), type = "prob")
    
    top_refchems_predictions <- predict(standardized_model, 
                                        newdata = format_LINCS_for_ML(LINCS_matrix = LINCS_data$LINCS_matrix,
                                                                      use_field = "pred",
                                                                      label_field = "exemplar"), type = "prob")
    
    null_predictions$label <- "null"
    null_predictions$use <- "supp_null"
    
    holdout_predictions_target$label <- "target"
    holdout_predictions_target$use <- "holdout"
    
    holdout_predictions_null$label <- "null"
    holdout_predictions_null$use <- "holdout"
    
    top_refchems_predictions$label <- "exemplar"
    top_refchems_predictions$use <- "exemplar"
    
    predictions <- data.frame(rbind(null_predictions, holdout_predictions_target, holdout_predictions_null, top_refchems_predictions))
    
    top_refchems_predictions <- data.table(cbind(LINCS_data$LINCS_metadata[LINCS_data$LINCS_metadata$label == "exemplar",], top_refchems_predictions))
    
    #caluclate the mean prediction across the profiles associated with each chemical
    top_refchems_predictions_temp_1 <- top_refchems_predictions[,.(mean_prediction = mean(target)), by = pert_iname]
    
    #tabulate the number of available profiles for each chemical
    top_refchems_predictions_temp_2 <- top_refchems_predictions[,.(profiles = length(target)), by = pert_iname]
    
    #distill the above two objects into one dataframe for easy export
    top_refchems_predictions <- cbind(top_refchems_predictions_temp_1, "profiles" = top_refchems_predictions_temp_2$profiles, "DTXSID" = unique(top_refchems_predictions$DTXSID))
    
    message("- finished caluclating probabilities -\n")
    variable_importance <- varImp(standardized_model, scale = TRUE)$importance
    variable_importance  <-variable_importance[order(variable_importance$target, decreasing = TRUE),]
    if (feature_opt == "all_genes" | feature_opt == "landmark_genes"){
      variable_importance <- data.frame("pr_gene_id" = row.names(variable_importance), "importance" = variable_importance[,1])
      variable_importance <- merge(variable_importance, gene_info)
      variable_importance  <-variable_importance[order(variable_importance$importance, decreasing = TRUE),]
    }
    variable_importance <- head(variable_importance, 200)
    
    #add to this object, other results objects
    standardized_model$confusion_matrix <- holdout_results
    standardized_model$pred <- predictions
    standardized_model$variable_importance <- variable_importance
    standardized_model$top_refchems_predictions <- top_refchems_predictions
    standardized_model$LINCS_metadata <- LINCS_data$LINCS_metadata
    
    message (" -removed matrix -\n")
    loop_end_time <- Sys.time()
    time_elapsed <- hms_span(loop_start_time,loop_end_time)
    
    standardized_results =data.frame("target_name" = target_name,
                                     "model_name" = model_name, 
                                     "internal_accuracy" = max(standardized_model$results$Accuracy), 
                                     "holdout_accuracy" = holdout_results$overall[1],
                                     "holdout_pvalue" = holdout_results$overall[6],
                                     "transformation"= "standardized",
                                     "target_members" = nrow(LINCS_data$LINCS_metadata[LINCS_data$LINCS_metadata$label == "target",]), 
                                     "holdout_members" = nrow(LINCS_data$LINCS_metadata[LINCS_data$LINCS_metadata$use == "holdout",]), 
                                     "time elapsed" = time_elapsed,
                                     "support_level" = support_level,
                                     "pert_itime" = pert_itime,
                                     "cell_id" = cell_id,
                                     "feature_opt" = feature_opt)
    
    # if (save_model == TRUE){
    #   print(paste0("assigning object: ", target_name,"_", model_name, "_fullmodel", " to environment"))
    #   assign(x = paste0(target_name,"_", model_name, "_fullmodel"),
    #          value = list("summary" = standardized_results,"model" = standardized_model)
    #          )
    #   print("saving model")
    #   save(file = paste0(output_dir, "/", target_name,"_", model_name,".Rdata"), list = c(paste0(target_name,"_", model_name, "_fullmodel")))
    #   print("removing model from environment")
    #   rm(list = c(paste0(target_name,"_", model_name, "_fullmodel")))
    # }
    
    
    if (save_model == TRUE){
      temp = list("summary" = standardized_results,"model" = standardized_model)
      message(paste0("- saving file ",output_dir, "/", target_name,"/", target_name,"_", model_name,".rds -\n"))
      dir.create(paste0(output_dir, "/",target_name))
      saveRDS(temp, file = paste0(output_dir, "/", target_name,"/", target_name,"_", model_name,".rds"))
      #rm(temp)
    }
    
    #remove this model matrix to reduce size of objects in memory   
    standardized_model$finalModel <- NULL
    standardized_model$trainingData <- NULL   
    
    
    results_summary = rbind(results_summary, standardized_results)
    
    if (return_model == TRUE){
      model_objects <- list.append(model_objects, "x" = standardized_model)
      names(model_objects)[length(model_objects)] <- paste0(target_name, "_", model_name)
    }
    
  }
  
  if (return_model == TRUE){
    expanded_result = list("results_summary" = results_summary, "model_objects" = model_objects)
    return(expanded_result)
  }
  
  if (return_model == FALSE){
    return(results_summary)
  }
  
}


# permute_models - run permutational models as a null control
#
# Parameters:
#  target_name (character) = name of the target_mode to for which a model should be trained
#  support_level (integer) = minimal support level used to filter refchemDB - this isn't explicitly used other than to record this parameter in output
#  pert_itime (character) = filtering criteria used to filter cmap_metadata - this isn't explicitly used other than to record this parameter in output
#  cell_id (character) = filtering criteria used to filter cmap_metadata - this isn't explicitly used other than to record this parameter in output
#  feature_opt (character) = either "all_genes" or "landmark_genes" or "pathway_score" - indicates what features will be used for modeling
#  model_names (vector) = vector of characters corresponding to model types recognized by caret 
#  cmap_mat (dataframe) = large LINCS dataframe containing gene expression values to be used for prediction
#  cmap_metadata (data.table) = metadata object after filtering cmap metadata
#  refchem_cleaned (data.table) = cleaned and filtered refchemDB object
#  seed (integer) = seed for controling RNG for reproducibility
#  verbose (boolean) = whether to print status messages to console
#  gene_info (data.frame) = gene metadata linking probes to gene names
#  exemplar_refchems (data.frame) = table of reference chemicals to exclude from training and to predict on
#
# Return Value:
#  (list) = returns a list containing two elements: a "results" dataframe that tabulates results metrics for each model and a 
#  "model_objects" list which contains more detailed model information for each model trained

permute_models <- function(target_name,
                           allowParallel_training = FALSE,
                           permutation_workers = 1,
                           cores,
                           seed,
                           iterations,
                           verbose = TRUE,
                           model_names,
                           support_level,
                           cell_id,
                           gene_info,
                           pert_itime,
                           feature_opt,
                           LINCS_matrix,
                           LINCS_metadata,
                           chemical_manifest,
                           exemplar_refchems,
                           refchem_file_raw,
                           ...)
{
  
  
  
  require(parallel)
  require(foreach)
  require(doParallel)
  require(rlist)
  registerDoParallel(cores=permutation_workers)
  results <- foreach(i=1:iterations, .combine = 'list.append', .init = list()) %dopar% {
    
    if (verbose == TRUE){
      message(paste0("- Generating permutation number ",i," with seed ", seed, " -\n"))
    }
    
    model_target(target_name= target_name, 
                 allowParallel_training = allowParallel_training,
                 model_names = model_names, 
                 generate_noise = TRUE,
                 support_level = support_level,
                 cell_id = cell_id,
                 pert_itime = pert_itime,
                 feature_opt = feature_opt,
                 LINCS_matrix = LINCS_matrix, 
                 LINCS_metadata = LINCS_metadata,
                 chemical_manifest = chemical_manifest,
                 return_model = TRUE,
                 verbose = FALSE,
                 seed = seed + i,
                 null_pred_size = 5,
                 gene_info = gene_info, 
                 exemplar_refchems = exemplar_refchems,
                 refchem_file_raw = refchem_file_raw,
                 save_model = FALSE)
  }
  



  #trim result output to just the necessary info
  summary_output = data.frame()
  LINCS_metadata_catcher = list()
  for (i in 1:length(results)){
    
    temp <-  data.frame("model_name" = results[[i]]$results_summary$model_name,
                        "iteration_number" = i,
                        "internal_accuracy" = results[[i]]$results_summary$internal_accuracy,
                        "holdout_accuracy" = results[[i]]$results_summary$holdout_accuracy)
    param_catcher = data.frame()
    for (j in 1:nrow(temp)){
      temp_name <- paste0(target_name, "_", temp$model_name[j])
      params <- results[[i]]$model_objects[[temp_name]]$bestTune
      param_catcher <- rbind.fill(param_catcher, params)
    }
    param_catcher$test <- NULL
    temp <- cbind(temp, param_catcher)
    
    summary_output <- rbind(summary_output, temp)
    
    LINCS_metadata_catcher <- list.append(LINCS_metadata_catcher, 
                                          list("iteration_number" = i,
                                               "LINCS_data" = results[[i]]$model_objects[[1]]$LINCS_metadata))
  }
  return(list("summary_output" = summary_output, "LINCS_metadata" = LINCS_metadata_catcher))
} 
  
  
  

perc_rank <- function(x, x0)  length(x[x <= x0])/length(x)*100



permutation_test <- function(target_name, 
                             model_names, 
                             seed = 123,
                             support_level = 5,
                             cell_id,
                             pert_itime,
                             feature_opt,
                             LINCS_matrix, 
                             LINCS_metadata,
                             chemical_manifest,
                             verbose = FALSE,
                             gene_info = gene_info, 
                             exemplar_refchems,
                             refchem_file_raw,
                             iterations = 10, 
                             permutation_workers = 2){
  require(parallel)
  require(foreach)
  require(doParallel)
  registerDoParallel(cores=cores)
  
  if (verbose == TRUE){
    message(paste0("- Generating standard model -\n"))
  }
  
  standard_results <-  model_target(target_name = target_name, 
                                    allowParallel_training = TRUE, #this is hard-coded to true, as this function is called by no others and this is not run in parallel
                                    model_names = model_names,
                                    generate_noise = FALSE,
                                    support_level = support_level,
                                    cell_id = cell_id,
                                    feature_opt = feature_opt,
                                    pert_itime = pert_itime,
                                    LINCS_matrix = LINCS_matrix, 
                                    LINCS_metadata = LINCS_metadata, 
                                    chemical_manifest = chemical_manifest, 
                                    return_model = TRUE, 
                                    seed = seed,
                                    verbose = verbose,
                                    null_pred_size = 1,
                                    gene_info = gene_info,
                                    exemplar_refchems = exemplar_refchems,
                                    refchem_file_raw = refchem_file_raw,
                                    save_model = FALSE)
  
  if (verbose == TRUE){
    message(paste0("- Generating permuted models -\n"))
  }
  
  permuted_results <- permute_models(target_name= target_name, 
                                     #cores = cores,
                                     allowParallel_training = FALSE, #this is hard-coded to false - increasing CPU utilization by setting permutation_workers allows for precise control
                                     permutation_workers = permutation_workers,
                                     model_names = model_names, 
                                     seed = seed,
                                     support_level = support_level,
                                     cell_id = cell_id,
                                     pert_itime = pert_itime,
                                     feature_opt = feature_opt,
                                     LINCS_matrix = LINCS_matrix, 
                                     LINCS_metadata = LINCS_metadata,
                                     chemical_manifest = chemical_manifest,
                                     return_model = FALSE,
                                     verbose = verbose,
                                     null_pred_size = 1,
                                     gene_info = gene_info, 
                                     exemplar_refchems = exemplar_refchems,
                                     refchem_file_raw = refchem_file_raw,
                                     iterations = iterations)
  
  catcher = data.frame()
  
  for (i in unique(permuted_results$summary_output$model_name)){
    
    filtered_permutation_summary = permuted_results$summary_output[permuted_results$summary_output$model_name == i,]
    filtered_standard_summary = standard_results$results_summary[standard_results$results_summary$model_name == i,]
    
    temp <- data.frame("model_name" = i,
                       "internal_accuracy" = filtered_standard_summary$internal_accuracy,
                       "holdout_accuracy" = filtered_standard_summary$holdout_accuracy,
                       "mean_permuted_internal_accuracy" = mean(filtered_permutation_summary$internal_accuracy),
                       "mean_permuted_holdout_accuracy" = mean(filtered_permutation_summary$holdout_accuracy),
                       # "internal_accuracy_percentile" = perc_rank(x0 = standard_results$results_summary$internal_accuracy, x = filtered_permutation_summary$internal_accuracy),
                       # "holdout_accuracy_percentile" = perc_rank(x0 = standard_results$results_summary$holdout_accuracy, x = filtered_permutation_summary$holdout_accuracy))
                       
                       #2/25/2021 - troubleshoot this - I think more filtering for the "standard result" may be necessary - is this returning a single value, or a vector of values for all the models generated?
                       #"Internal_Empirical_Pval" = nrow(filtered_permutation_summary[filtered_permutation_summary$internal_accuracy >= standard_results$results_summary$internal_accuracy,])/iterations,
                       #"Holdout_Empirical_Pval" = nrow(filtered_permutation_summary[filtered_permutation_summary$holdout_accuracy >= standard_results$results_summary$holdout_accuracy,])/iterations)
                       "Internal_Empirical_Pval" = nrow(filtered_permutation_summary[filtered_permutation_summary$internal_accuracy >= filtered_standard_summary$internal_accuracy,])/iterations,
                       "Holdout_Empirical_Pval" = nrow(filtered_permutation_summary[filtered_permutation_summary$holdout_accuracy >= filtered_standard_summary$holdout_accuracy,])/iterations)
    
    catcher = rbind(catcher, temp)
  }
  
  return(list("permutation_summary" = catcher,
              "permutation_source_data" = permuted_results))
  
}



# model_targets - generate predictive models for a multiple target_modes using refchemDB labels and LINCS gene expression
#  this is mainly a wrapper function for model_target which simply iterates through column of profile_table and runs model_targets with parallelization
#
# Parameters:
#  profile_table (data.frame) = table from table_LINCS_profiles() to iterate through for target_mode selection
#  support_level (integer) = minimal support level used to filter refchemDB - this isn't explicitly used other than to record this parameter in output
#  pert_itime (character) = filtering criteria used to filter cmap_metadata - this isn't explicitly used other than to record this parameter in output
#  cell_id (character) = filtering criteria used to filter cmap_metadata - this isn't explicitly used other than to record this parameter in output
#  feature_opt (character) = either "all_genes" or "landmark_genes" or "pathway_score" - indicates what features will be used for modeling
#  model_names (vector) = vector of characters corresponding to model types recognized by caret 
#  LINCS_matrix (dataframe) = large LINCS dataframe containing gene expression values to be used for prediction
#  LINCS_metadata (data.table) = metadata object after filtering cmap metadata
#  chemical_manifest (data.table) = cleaned and filtered refchemDB object
#  return_model (boolean) = whether to export full model information along with result summary
#  seed (integer) = seed for controling RNG for reproducibility
#  verbose (boolean) = whether to print status messages to console
#  cores (integer) = number of cores to use for parallelization - caution, some models will use parallelization as well - would not recommend exceeding 4
#  null_pred_size (integer) = number of null profiles for model to generate predictions for
#  gene_info (data.frame) = gene metadata linking probes to gene names
#  exemplar_refchems (data.frame) = table of reference chemicals to exclude from training and to predict on
#  refchem_file_raw (character) = full path to raw refchem file
#  save_model (boolean) = should model be saved to disk?
#  output_dir (character) = full path to where models should be saved - only relevant if save_model is set to TRUE
#
# Return Value:
#  (list) = returns a list of lists.  Each top level element represents a result from a single target_mode
#   These elements are lists of two elements: a "results" dataframe that tabulates results metrics for each model and a 
#  "model_objects" list which contains more detailed model information for each model trained

model_targets <- function(profile_table, 
                          allowParallel_training = FALSE,
                          target_workers = 1,
                          permutation_workers = 1,
                          generate_noise = FALSE,
                          add_permutations= FALSE,
                          iterations = NULL,
                          support_level,
                          cell_id,
                          pert_itime,
                          feature_opt,
                          model_names, 
                          LINCS_matrix, 
                          LINCS_metadata,
                          LINCS_gene_info,
                          chemical_manifest, 
                          return_model = FALSE, 
                          seed = 123, 
                          verbose = TRUE, 
                          #cores = 2,
                          null_pred_size,
                          gene_info,
                          exemplar_refchems,
                          refchem_file_raw,
                          save_model = FALSE,
                          output_dir = NULL){
  require(parallel)
  require(foreach)
  require(doParallel)
  require(rlist)
  registerDoParallel(cores=target_workers)
  message(paste0("- running model_targets with ",getDoParWorkers(), " parallel MIE workers -"))
  results = list()
  results <- foreach(i=profile_table$target_mode, .combine = 'list.append', .init = list()) %dopar% {
    message(paste0("- processing MIE number ", which(profile_table$target_mode == i)," of ", length(profile_table$target_mode)), " -\n")
    model_object <- model_target(target_name = i, 
                                 allowParallel_training = allowParallel_training,
                                 model_names = model_names,
                                 generate_noise = generate_noise,
                                 support_level = support_level,
                                 cell_id = cell_id,
                                 feature_opt = feature_opt,
                                 pert_itime = pert_itime,
                                 LINCS_matrix = LINCS_matrix, 
                                 LINCS_metadata = LINCS_metadata, 
                                 chemical_manifest = chemical_manifest, 
                                 return_model = return_model, 
                                 seed = seed,
                                 verbose = verbose,
                                 null_pred_size = null_pred_size,
                                 gene_info = gene_info,
                                 exemplar_refchems = exemplar_refchems,
                                 refchem_file_raw = refchem_file_raw,
                                 save_model = save_model,
                                 output_dir = output_dir)
    if(add_permutations == TRUE){
      
      message(paste0("- Running ", iterations, " permutations of ", i, " with ", length(model_names), " algorithms -\n"))
      
      permuted_results <- permute_models(target_name = i,
                                         #cores = 1,
                                         permutation_workers = permutation_workers,
                                         allowParallel_training = FALSE, #hard coded to false, use permutation workers to better control parallelization
                                         seed = seed,
                                         iterations = iterations,
                                         verbose = TRUE,
                                         model_names = model_names,
                                         support_level = support_level,
                                         cell_id = cell_id,
                                         gene_info = gene_info,
                                         pert_itime = pert_itime,
                                         feature_opt = feature_opt,
                                         LINCS_matrix = LINCS_matrix,
                                         LINCS_metadata = LINCS_metadata,
                                         chemical_manifest = chemical_manifest,
                                         exemplar_refchems = exemplar_refchems,
                                         refchem_file_raw = refchem_file_raw)
      
      
      
      catcher = data.frame()
      
      for (j in unique(permuted_results$summary_output$model_name)){
        
        filtered_permutation_summary = permuted_results$summary_output[permuted_results$summary_output$model_name == j,]
        filtered_standard_summary = standard_results$results_summary[standard_results$results_summary$model_name == j,]
        
        temp <- data.frame("model_name" = j,
                           "internal_accuracy" = filtered_standard_summary$internal_accuracy,
                           "holdout_accuracy" = filtered_standard_summary$holdout_accuracy,
                           "mean_permuted_internal_accuracy" = mean(filtered_permutation_summary$internal_accuracy),
                           "mean_permuted_holdout_accuracy" = mean(filtered_permutation_summary$holdout_accuracy),
                           # "internal_accuracy_percentile" = perc_rank(x0 = standard_results$results_summary$internal_accuracy, x = filtered_permutation_summary$internal_accuracy),
                           # "holdout_accuracy_percentile" = perc_rank(x0 = standard_results$results_summary$holdout_accuracy, x = filtered_permutation_summary$holdout_accuracy))
                           
                           #2/25/2021 - troubleshoot this - I think more filtering for the "standard result" may be necessary - is this returning a single value, or a vector of values for all the models generated?
                           #"Internal_Empirical_Pval" = nrow(filtered_permutation_summary[filtered_permutation_summary$internal_accuracy >= standard_results$results_summary$internal_accuracy,])/iterations,
                           #"Holdout_Empirical_Pval" = nrow(filtered_permutation_summary[filtered_permutation_summary$holdout_accuracy >= standard_results$results_summary$holdout_accuracy,])/iterations)
                           "Internal_Empirical_Pval" = nrow(filtered_permutation_summary[filtered_permutation_summary$internal_accuracy >= filtered_standard_summary$internal_accuracy,])/iterations,
                           "Holdout_Empirical_Pval" = nrow(filtered_permutation_summary[filtered_permutation_summary$holdout_accuracy >= filtered_standard_summary$holdout_accuracy,])/iterations)
        
        catcher = rbind(catcher, temp)
      }
      
      # model_object$permutation_data = list("summary" = catcher,
      #             "source_data" = permuted_results)
      
      
      saveRDS(object =  list("permutation_summary" = catcher,
                             "permutation_source_data" = permuted_results),
              file = paste0(output_dir, "/", i, "/", i, "_permutation_results.rds"))
      
      
    }  
    
    
    model_object
  } 
  names(results) <- profile_table$target_mode
  return(results)
}



# ml_job - generate predictive models for a multiple target_modes using refchemDB labels and LINCS gene expression
#  this is a wrapper function around several lower-level functions which does target-chemical tabulation, filtering, and modeling
#  all in one step
#
# Parameters:
#  refchem_file_raw (character) = full path to RefchemDB file - only required if collapse_targets =! "static"
#  preprocessed_targets_path (character) = full path to preprocessed collapsed refchemDB file - only required if collapse_targets == "static"
#  collapse targets (character) = "static" or "dynamic" or "none"
#  h (numeric) distance metric to be used for collapsed targets
#  LINCS_directory (character) = full path to LINCS metadata directory
#  min_profiles (integer) = minimum number of LINCS profiles required for a target_mode to persist
#  min_chemicals (integer) = minimum number of the set of chemicals associated with LINCS profiles required for a target_mode to persist
#  support_level (integer) = minimal support level used to filter refchemDB - this isn't explicitly used other than to record this parameter in output
#  pert_itime (character) = filtering criteria used to filter cmap_metadata - this isn't explicitly used other than to record this parameter in output
#  cell_id (character) = filtering criteria used to filter cmap_metadata - this isn't explicitly used other than to record this parameter in output
#  model_names (vector) = vector of characters corresponding to model types recognized by caret 
#  return_model (boolean) = whether to export full model information along with result summary
#  seed (integer) = seed for controling RNG for reproducibility
#  verbose (boolean) = whether to print status messages to console
#  cores (integer) = number of cores to use for parallelization - caution, some models will use parallelization as well - would not recommend exceeding 4
#  null_pred_size (integer) = number of null profiles for model to generate predictions for
#  exemplar_refchems_path (character) = full path to exemplar refchem file
#  feature_opt (character) = either "all_genes" or "landmark_genes" or "pathway_score" - what type of features should be used in training?
#  save_model (boolean) = should model be saved to disk?
#  output_dir (character) = full path to where models should be saved - only relevant if save_model is set to TRUE
#  signature_path (character) = full path to gene signature file
#
# Return Value:
#  (list) = returns a list of lists.  Each top level element represents a result from a single target_mode
#   These elements are lists of two elements: a "results" dataframe that tabulates results metrics for each model and a 
#  "model_objects" list which contains more detailed model information for each model trained


ml_job <- function(LINCS_directory, 
                   LINCS_raw_directory = "/share/home3/jbundy/cmap_raw/",
                   DTXSID_index_file,
                   allowParallel_training,
                   add_permutations = FALSE,
                   iterations = NULL,
                   preprocessed_targets_path = NULL,
                   support_level,
                   cell_id, 
                   feature_opt,
                   pert_itime, 
                   min_chemicals = 0, 
                   min_profiles = 50, 
                   model_names, 
                   #cores = 2, 
                   target_workers = 1,
                   permutation_workers = 1,
                   verbose = TRUE,
                   return_model = TRUE,
                   seed = 123,
                   collapsed_targets = "static",
                   h = 0.3,
                   method = "complete",
                   null_pred_size = 200,
                   profile_limit = 20,
                   signature_path= "/share/projects/HTTr/HTTr_pipeline_dev/HumanWT_v1/Analysis/Bundy/input/c2.cp.v7.1.symbols.txt",
                   save_model = FALSE,
                   output_dir = NULL){
  require(rlist)
  
  #this is now the only option but i left it in to stress that refchemdb data are processed
  #moved "dynamic" and "none" options in this version on 6/15/2020
  if (collapsed_targets == "static"){
    message("- importing preprocessed refchem manifest -\n")
    load(file= preprocessed_targets_path)
    chemical_manifest <- preprocessed_collapsed_targets$collapsed_targets
    chemical_manifest <- chemical_manifest[chemical_manifest$support >= support_level,]
    jaccard_matrix <- preprocessed_collapsed_targets$jaccard_matrix
    groups <- preprocessed_collapsed_targets$groups
    message("- importing LINCS gene info- -\n")
    gene_info <- data.table(read.csv(header = TRUE, file = paste0(LINCS_directory,"phase_1/GSE92742_Broad_LINCS_gene_info.txt"), sep = "\t"))
    message("- tabulating preprocessed targets -\n")
    target_table <- table_targets(chemical_manifest)
    message("- importing LINCS metadata -\n")
    LINCS_metadata <- import_LINCS_metadata(LINCS_directory = LINCS_directory, cell_id = cell_id, pert_itime = pert_itime, chemical_manifest = chemical_manifest, DTXSID_index_file = DTXSID_index_file)
    message("- trimming LINCS metadata -\n")
    LINCS_metadata <- trim_LINCS_metadata(LINCS_metadata = LINCS_metadata, seed = seed, profile_limit = profile_limit)
    #exemplar_refchems <- exemplar_refchems[exemplar_refchems$use_me == 1,]
    #disabled 10/2/2020
    message("- tabulating LINCS profiles -\n")
    profile_table <- table_LINCS_profiles(target_table = target_table, 
                                          LINCS_metadata = LINCS_metadata, 
                                          chemical_manifest = chemical_manifest,
                                          min_chemicals = min_chemicals,
                                          min_profiles = min_profiles)
    
    message("- identifying top reference chemicals for tabulated targets -\n")
    exemplar_refchems <- fetch_exemplar_refchems_2(chemical_manifest = chemical_manifest,
                                                   LINCS_metadata = LINCS_metadata,
                                                   profile_table = profile_table,
                                                   min_chemicals = min_chemicals,
                                                   min_profiles = min_profiles,
                                                   target_table = target_table)
    
    message("- re-tabulating LINCS profiles excluding exemplar reference chemicals -\n")
    profile_table <- table_LINCS_profiles(target_table = target_table, 
                                          LINCS_metadata = LINCS_metadata, 
                                          chemical_manifest = chemical_manifest,
                                          min_chemicals = min_chemicals,
                                          min_profiles = min_profiles,
                                          exemplar_refchems = exemplar_refchems)
    
    #flips the order in which MIEs are modeled - useful if you had to kill a job halfway through and want to restart the job working from the other end of the table
    profile_table <- profile_table[order(profile_table$LINCS_profiles, decreasing = FALSE),]
    
  }
  
  
  message("- importing relevant cmap expression data -\n")
  
  #import LINCS gene expression profiles - if we use pathway score calculation, do not normalize the moderated zscores in this step
  if(feature_opt == "landmark_genes" | feature_opt == "all_genes"){
    LINCS_matrix <- fetch_LINCS_profiles(LINCS_raw_directory = LINCS_raw_directory, 
                                         LINCS_metadata = LINCS_metadata,
                                         normalize = TRUE)}
  
  if(feature_opt == "pathway_score"){
    LINCS_matrix <- fetch_LINCS_profiles(LINCS_raw_directory = LINCS_raw_directory, 
                                         LINCS_metadata = LINCS_metadata,
                                         normalize = FALSE)
    message("- importing pathway signatures -\n")
    sigdb <- import_GSEA_signatures(signature_path)
  }
  
  
  #if this default is overridden - train models only on landmark genes
  if(feature_opt == "landmark_genes"){
    gene_info <- gene_info[gene_info$pr_is_lm == 1,]
    LINCS_matrix <- LINCS_matrix[,c(as.character(gene_info$pr_gene_id), "sig_id"), with = FALSE]
  }
  
  
  if(feature_opt == "pathway_score"){
    LINCS_matrix <- calculate_pathway_scores(LINCS_matrix = LINCS_matrix, 
                                             LINCS_metadata = LINCS_metadata,
                                             signature_list = sigdb,
                                             gene_info = gene_info,
                                             normalize = TRUE)
  }
  
  
  message(paste0("- training models for ", length(profile_table$target_mode), " MIE targets with ", length(model_names)," algorithms -\n"))
  modeling_result <-model_targets(profile_table = profile_table, 
                                  target_workers = target_workers,
                                  permutation_workers = permutation_workers,
                                  allowParallel_training = allowParallel_training,
                                  generate_noise = FALSE,
                                  add_permutations = add_permutations,
                                  iterations = iterations,
                                  model_names = model_names, 
                                  support_level = support_level,
                                  pert_itime = pert_itime,
                                  cell_id = cell_id,
                                  feature_opt = feature_opt,
                                  LINCS_matrix = LINCS_matrix, 
                                  LINCS_metadata = LINCS_metadata,
                                  chemical_manifest = chemical_manifest,
                                  return_model = return_model,
                                  verbose = verbose,
                                  seed = seed, 
                                  #cores = cores,
                                  null_pred_size = null_pred_size,
                                  gene_info = gene_info,
                                  exemplar_refchems = exemplar_refchems,
                                  refchem_file_raw = refchem_file_raw,
                                  save_model = save_model,
                                  output_dir = output_dir)
  
  output = list("profile_table" = profile_table,
                "modeling_result" =  modeling_result)
  if (collapsed_targets == "dynamic" | collapsed_targets == "static"){
    output = list.append(output, "jaccard_matrix" = jaccard_matrix)
    output = list.append(output, "groups" = groups)
  }
  return(output)
}



# ml_analysis - generate predictive models for a multiple target_modes using refchemDB labels and LINCS gene expression
#  this is a wrapper function around ml_job which takes a set of different lists of filtering criteria and generating a set of unique 
#  filtering criteria.  This list is iterated over and one ml_job is initiated per list using its parameters.  
#
# Parameters:
#  refchem_file_raw (character) = full path to RefchemDB file
#  preprocessed_targets_path (character) = full path to preprocessed collapsed refchemDB file - only required if collapsed_targets == "static"
#  collapse targets (character) = "static" or "dynamic" or "none"
#  support_levels (vector) = vector of support levels for filtering RefchemDB
#  pert_itimes (vector) = vector of exposure durations for filtering LINCS metadata
#  cell_ids (vector) = vector of cell types to be used for filtering LINCS metadata
#  LINCS_directory (character) = full path to LINCS metadata directory
#  LINCS_raw_directory (character) = full path to LINCS raw data organized into phase_1 and phase_2 subdirectories
#  min_profiles (integer) = minimum number of LINCS profiles required for a target_mode to persist
#  min_chemicals (integer) = minimum number of the set of chemicals associated with LINCS profiles required for a target_mode to persist
#  model_names (vector) = vector of characters corresponding to model types recognized by caret 
#  return_model (boolean) = whether to export full model information along with result summary
#  seed (integer) = seed for controling RNG for reproducibility
#  verbose (boolean) = whether to print status messages to console
#  cores (integer) = number of cores to use for parallelization - caution, some models will use parallelization as well - would not recommend exceeding 4
#  output_dir (character) = path to output directory to save objects
#  null_pred_size (integer) = number of null profiles for model to generate predictions for
#  top_refchems_path (character) = full path of .csv file with top reference chemicals to exclude from training
#  profile_limit (integer) = maximum number of profiles included in training for any single chemical
#  landmark_opts (vector) = a list containing 1, 0, or both 1 and 0.  1 will run the analysis and consider only landmark transcripts.  0 will run the analysis with both landmark and inferred values
#  save_model (boolean) = should models be saved?
#  signature_path (character) = full path to gene signature file
#
# Return Value:
#  (list) = returns a list of lists.  Each top level element represents a result from a single target_mode
#   These elements are lists of two elements: a "results" dataframe that tabulates results metrics for each model and a 
#  "model_objects" list which contains more detailed model information for each model trained

ml_analysis <- function(support_levels, 
                        target_workers = 1,
                        permutation_workers = 1,
                        iterations = NULL,
                        allowParallel_training = FALSE,
                        pert_itimes, 
                        cell_ids,
                        add_permutations = FALSE,
                        feature_opts,
                        LINCS_directory, 
                        LINCS_raw_directory = "/share/home3/jbundy/cmap_raw/",
                        #refchem_file_raw,
                        min_chemicals, 
                        min_profiles, 
                        model_names, 
                        #cores, 
                        verbose,
                        return_model,
                        seed,
                        output_dir,                   
                        h = NULL,
                        method = NULL,
                        collapsed_targets = "static",
                        preprocessed_targets_path = NULL,
                        null_pred_size = 200,
                        profile_limit = 20,
                        signature_path = "/share/projects/HTTr/HTTr_pipeline_dev/HumanWT_v1/Analysis/Bundy/input/c2.cp.v7.1.symbols.txt",
                        save_model = FALSE,
                        DTXSID_index_file){
  require(data.table)
  
  dir_status = dir.exists(output_dir)
  
  #if the directory exists, quit out with message
  if (dir_status == TRUE){
    message("- output directory already exists -\n")
    return()
  }
  if (dir_status == FALSE){
    message("- creating output directory -\n")
    dir.create(output_dir)
  }
  
  ml_analysis_result <- list()
  
  #generate a set of all combinations of analysis prameters to hand off to ml_job
  conditions <- expand.grid("support_level" = support_levels,
                            "pert_itime" = pert_itimes, 
                            "cell_id" = cell_ids, 
                            "feature_opt" = feature_opts)
  
  #iterate through each set of analysis conditions and call ml_job with those options
  for (i in 1:length(conditions[,1])){
    tryCatch(expr = {
      
      #generate a design name string to help keep track of design options
      design_name <- sub(pattern = " ", 
                         x = paste0(names(conditions)[1], conditions$support_level[i],"_", 
                                    names(conditions)[2], conditions$pert_itime[i],"_",
                                    names(conditions)[3], conditions$cell_id[i],"_",
                                    names(conditions)[4], conditions$feature_opt[i],"_"),
                         replacement = "_")
      message("- starting analyses for the following analyes -\n")
      
      print(design_name)
      
      subdir_status = dir.exists(paste0(output_dir, "/", design_name))
      
      #if the directory exists, quit out with message
      if (dir_status == TRUE){
        message("- output directory already exists -\n")
        return()
      }
      if (dir_status == FALSE){
        message("- creating output directory -\n")
        dir.create(paste0(output_dir, "/", design_name))
        dir.create(paste0(output_dir, "/", design_name, "/saved_models"))
      }
      
      
      #call ml_job with the relevant analysis options
      job = ml_job(#refchem_file_raw = refchem_file_raw, 
        LINCS_directory = LINCS_directory, 
        target_workers = target_workers,
        permutation_workers = permutation_workers,
        allowParallel_training = allowParallel_training,
        iterations = iterations,
        add_permutations = add_permutations,
        support_level = as.numeric(conditions$support_level[i]),
        cell_id = as.character(conditions$cell_id[i]), 
        pert_itime = as.character(conditions$pert_itime[i]),
        feature_opt = as.character(conditions$feature_opt[i]), 
        min_chemicals = min_chemicals, 
        min_profiles = min_profiles, 
        model_names = model_names, 
        #cores = cores, 
        verbose = verbose,
        return_model= return_model,
        seed = seed,
        h = h,
        method = method,
        collapsed_targets = collapsed_targets,
        preprocessed_targets_path = preprocessed_targets_path,
        null_pred_size = null_pred_size,
        profile_limit = profile_limit,
        signature_path = signature_path,
        DTXSID_index_file = DTXSID_index_file,
        save_model = save_model,
        output_dir = paste0(output_dir, "/", design_name, "/saved_models"))
      
      #save this design name into the object for later
      job$design_name <- design_name
      
      #assign result object to an object name equal to its design name and write this out to an R object
      #this becomes useful later when reading in multiple objects with different analysis parameters
      assign(x = design_name,
             envir=.GlobalEnv,
             value = job)
      save(list = c(design_name), file = paste0(output_dir, "/", design_name, "/", design_name, ".Rdata"))
      
      #overwrite result object with empty list to cut down on memory usage
      assign(x = design_name,
             envir=.GlobalEnv,
             value = list())
      gc()
    },
    error = function(e){
      message("*** Caught an error on itertion ***", i, "-\n")
      print(e)})
  }
  #  return(ml_analysis_result)
}






